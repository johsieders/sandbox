# generated by GPT 4.1, 21.06.2025
# project Owner: Johannes Siedersleben
#
import bisect
import functools
import heapq
import operator
from typing import Iterable, Sequence, Tuple, Any, Union, Callable

Timestamp = Union[int, float, None, str]  # Now allows None or "-oo"
TvPair = Tuple[Timestamp, Any]


def is_number(x) -> bool:
    return isinstance(x, (int, float)) and not isinstance(x, bool)


def merge_timestamps(*tv_lists):
    iterables = []
    for tv in tv_lists:
        for t, _ in tv:
            # Normalize "-oo" string to None
            yield None if t == "-oo" else t
    # Remove duplicates and sort, with None (representing -âˆž) always first
    seen = set()
    result = []
    for t in heapq.merge(*[sorted(set(t for t, _ in tv)) for tv in tv_lists]):
        norm_t = None if t == "-oo" else t
        if norm_t not in seen:
            result.append(norm_t)
            seen.add(norm_t)
    return result


class Stepfun:
    """
    Step function on the real line, right-continuous.
    The first tv-pair can be (None, value) or ("-oo", value) to define the value for x < first timestamp.
    """
    __slots__ = ('_tv_list',)

    _tv_list: Tuple[TvPair, ...]

    def __init__(self, tv_list: Iterable[TvPair] | 'Stepfun'):
        if isinstance(tv_list, Stepfun):
            self._tv_list = tv_list._tv_list
            return

        items = []
        for pair in tv_list:
            if not (isinstance(pair, tuple) and len(pair) == 2):
                raise TypeError("Each tv-pair must be a tuple (timestamp, value).")
            t, v = pair
            if t == "-oo":
                t = None
            if not (isinstance(t, (int, float)) or t is None):
                raise TypeError("Timestamps must be int, float, None, or '-oo'.")
            items.append((t, v))
        if not items:
            raise ValueError("tv_list must not be empty.")

        # Sort: None (or "-oo") always first, then ascending numbers
        items.sort(key=lambda pair: (float('-inf') if pair[0] is None else pair[0]))
        # If first timestamp isn't None, insert (None, value) with same value as first
        if items[0][0] is not None:
            items = [(None, items[0][1])] + items
        # Keep only the last value for duplicate timestamps
        norm = []
        for t, v in items:
            if norm and norm[-1][0] == t:
                norm[-1] = (t, v)
            else:
                norm.append((t, v))
        # Merge consecutive intervals with the same value
        merged = []
        for t, v in norm:
            if not merged or merged[-1][1] != v:
                merged.append((t, v))
        self._tv_list = tuple(merged)

    @property
    def tv_list(self) -> Tuple[TvPair, ...]:
        return self._tv_list

    def __repr__(self) -> str:
        return f"Stepfun({self._tv_list})"

    def __str__(self) -> str:
        return f"Stepfun{self._tv_list}"

    def __call__(self, x: Timestamp) -> Any:
        # Evaluate at any real x, using first value for x less than all breakpoints
        tv = self._tv_list
        times = [float('-inf') if t is None else t for t, _ in tv]
        idx = bisect.bisect_right(times, x) - 1
        if idx < 0:
            idx = 0
        return tv[idx][1]

    def __neg__(self) -> 'Stepfun':
        def negval(v):
            return -v if is_number(v) else v

        return Stepfun(((t, negval(v)) for t, v in self._tv_list))

    def __abs__(self) -> 'Stepfun':
        def absval(v):
            return abs(v) if is_number(v) else v

        return Stepfun(((t, absval(v)) for t, v in self._tv_list))

    @staticmethod
    def _combine(fs: Sequence['Stepfun'], op: Callable, identity: Any = None, left_assoc: bool = False) -> 'Stepfun':
        if not fs:
            raise ValueError("At least one step function required.")
        tv_lists = [f._tv_list for f in fs]
        # Merge all timestamps, taking care of None (which always sorts first)
        timestamps = sorted(set(t for tv in tv_lists for t, _ in tv), key=lambda t: float('-inf') if t is None else t)
        idxs = [0] * len(fs)
        lengths = [len(tv) for tv in tv_lists]
        result = []
        for t in timestamps:
            current = []
            for i, tv in enumerate(tv_lists):
                while idxs[i] + 1 < lengths[i] and (
                        float('-inf') if tv[idxs[i] + 1][0] is None else tv[idxs[i] + 1][0]) <= (
                        float('-inf') if t is None else t):
                    idxs[i] += 1
                current.append(tv[idxs[i]][1])
            # Excel logic: propagate first non-numeric
            for val in current:
                if not is_number(val):
                    v = val
                    break
            else:
                if left_assoc:
                    v = current[0]
                    for val in current[1:]:
                        v = op(v, val)
                else:
                    v = functools.reduce(op, current, identity)
            if not result or result[-1][1] != v:
                result.append((t, v))
        return Stepfun(result)

    @staticmethod
    def sum(*fs: 'Stepfun') -> 'Stepfun':
        return Stepfun._combine(fs, operator.add, 0, left_assoc=False)

    @staticmethod
    def multiply(*fs: 'Stepfun') -> 'Stepfun':
        return Stepfun._combine(fs, operator.mul, 1, left_assoc=False)

    def __add__(self, other: 'Stepfun') -> 'Stepfun':
        return Stepfun.sum(self, other)

    def __mul__(self, other: 'Stepfun') -> 'Stepfun':
        return Stepfun.multiply(self, other)

    def __sub__(self, other: 'Stepfun') -> 'Stepfun':
        def sub(x, y):
            if not is_number(x): return x
            if not is_number(y): return y
            return x - y

        return Stepfun._combine([self, other], sub, left_assoc=True)

    def __truediv__(self, other: 'Stepfun') -> 'Stepfun':
        def div(x, y):
            if not is_number(x): return x
            if not is_number(y): return y
            if y == 0: return "DIV/0"
            return x / y

        return Stepfun._combine([self, other], div, left_assoc=True)

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, Stepfun):
            return NotImplemented
        # Merge all timestamps for complete comparison, including None/"-oo"
        all_timestamps = sorted(set(t for t, _ in self._tv_list) | set(t for t, _ in other._tv_list),
                                key=lambda t: float('-inf') if t is None else t)
        for t in all_timestamps:
            if self(float('-inf') if t is None else t) != other(float('-inf') if t is None else t):
                return False
        return True

    def _diff(self, other: 'Stepfun') -> 'Stepfun':
        return self.__sub__(other)

    def __lt__(self, other: 'Stepfun') -> bool:
        diff = self._diff(other)
        all_timestamps = sorted(set(t for t, _ in self._tv_list) | set(t for t, _ in other._tv_list),
                                key=lambda t: float('-inf') if t is None else t)
        for t in all_timestamps:
            v = diff(float('-inf') if t is None else t)
            if not is_number(v):
                return False
            if v >= 0:
                return False
        return True

    def __le__(self, other: 'Stepfun') -> bool:
        diff = self._diff(other)
        all_timestamps = sorted(set(t for t, _ in self._tv_list) | set(t for t, _ in other._tv_list),
                                key=lambda t: float('-inf') if t is None else t)
        for t in all_timestamps:
            v = diff(float('-inf') if t is None else t)
            if not is_number(v):
                return False
            if v > 0:
                return False
        return True

    def __gt__(self, other: 'Stepfun') -> bool:
        return other.__lt__(self)

    def __ge__(self, other: 'Stepfun') -> bool:
        return other.__le__(self)

    def integrate(self, start: Timestamp, end: Timestamp) -> float:
        # Only meaningful if both bounds are numbers
        if not isinstance(start, (int, float)) or not isinstance(end, (int, float)):
            raise ValueError("Integration bounds must be numbers.")
        if start > end:
            raise ValueError("Start must be <= end.")
        if start == end:
            return 0.0
        tv = self._tv_list
        times = [float('-inf') if t is None else t for t, _ in tv]
        # Only add change points in (start, end)
        points = [start]
        for t in times:
            if start < t < end:
                points.append(t)
        points.append(end)
        points.sort()
        total = 0.0
        for i in range(len(points) - 1):
            x0 = points[i]
            x1 = points[i + 1]
            val = self(x0)
            if is_number(val):
                total += (x1 - x0) * val
        return total

# End of improved Stepfun
