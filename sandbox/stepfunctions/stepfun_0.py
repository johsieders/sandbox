# generated by GPT 4.1, 21.06.2025
# project Owner: Johannes Siedersleben
#
#
#   A step function is given by a list of (timestamp, value)-pairs, or tv-pairs for short.
#   Examples:
#   ((0, 100),) represents a function that is constant = 100 for 0 <= x < +oo.
#   ((0, 100), 20, 200)) represents a function that is constant = 100 for 0 <= x < 20, and constant = 200 on [20, +oo)
#   We only consider right-continuous step functions defined on [0, +oo).
#   A valid tv-list satisfies four conditions:
#   1) It starts at 0, that is, the first tv-pair is like (0, some_value)
#   2) The values are int or float
#   3) The timestamps are strictly ascending.
#   4) The value changes at every timestamp.
#   An invalid tv-list containing (0, some_value) can be normalized by sorting by stamps, merging intervals with equal values.
#
#   The class Stepfun does (at least) the following:
#   a) The constructor accepts a tv_list or another Stepfun.
#   b) It overloads unary minus, abs
#   c) It overloads +, -, *, ==, <, <=, >, >=
#   d) it implements integrate(self, from, to) with the usual meaning
#   Note that the timestamps of, say f + g, are the union of the timestamps of f and of g,
#   with some timestamps possibly normalized away.
#   Example:
#   Stepfun(((0,2), (10, 1))) + Stepfun(((0,1), (10, 2))) = Stepfun(((0,3),))
#
# Generated by GPT 4.1
# 20.06.2025

import bisect
from typing import Iterable, Sequence, Tuple, Union, Any

Number = Union[int, float]
TvPair = Tuple[Number, Number]
TvList = Sequence[TvPair]


class Stepfun:
    __slots__ = ('_tv_list',)

    _tv_list: Tuple[TvPair, ...]

    def __init__(self, tv_list: Iterable[TvPair] | 'Stepfun'):
        if isinstance(tv_list, Stepfun):
            self._tv_list = tv_list._tv_list
            return

        items = []
        for pair in tv_list:
            if not (isinstance(pair, tuple) and len(pair) == 2):
                raise TypeError("Each tv-pair must be a tuple of (timestamp, value).")
            t, v = pair
            if not isinstance(t, (int, float)) or not isinstance(v, (int, float)):
                raise TypeError("Timestamps and values must be int or float.")
            items.append((float(t), float(v)))

        if not items:
            raise ValueError("tv_list must not be empty.")

        items.sort()
        norm = []
        for t, v in items:
            if norm and norm[-1][0] == t:
                norm[-1] = (t, v)
            else:
                norm.append((t, v))

        merged = []
        for t, v in norm:
            if not merged or merged[-1][1] != v:
                merged.append((t, v))
        if merged[0][0] != 0:
            raise ValueError("tv_list must start at timestamp 0.")
        for i in range(1, len(merged)):
            if merged[i][0] <= merged[i - 1][0]:
                raise ValueError("Timestamps must be strictly ascending.")
            if merged[i][1] == merged[i - 1][1]:
                raise ValueError("Redundant value at timestamp %s." % merged[i][0])
        self._tv_list = tuple(merged)

    @property
    def tv_list(self) -> Tuple[TvPair, ...]:
        return self._tv_list

    def __repr__(self) -> str:
        return f"Stepfun({self._tv_list})"

    def __str__(self) -> str:
        return f"Stepfun{self._tv_list}"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, Stepfun):
            return NotImplemented
        return self._tv_list == other._tv_list

    def __hash__(self):
        return hash(self._tv_list)

    def __neg__(self) -> 'Stepfun':
        return Stepfun(((t, -v) for t, v in self._tv_list))

    def __abs__(self) -> 'Stepfun':
        return Stepfun(((t, abs(v)) for t, v in self._tv_list))

    def _binary_op(self, other: 'Stepfun', op) -> 'Stepfun':
        if not isinstance(other, Stepfun):
            raise TypeError("Operand must be Stepfun.")
        times = sorted(set(t for t, _ in self._tv_list) | set(t for t, _ in other._tv_list))
        v1 = self._tv_list
        v2 = other._tv_list
        i1 = i2 = 0
        n1 = len(v1)
        n2 = len(v2)
        cur1 = v1[0][1]
        cur2 = v2[0][1]
        result = []
        for t in times:
            while i1 + 1 < n1 and v1[i1 + 1][0] <= t:
                i1 += 1
                cur1 = v1[i1][1]
            while i2 + 1 < n2 and v2[i2 + 1][0] <= t:
                i2 += 1
                cur2 = v2[i2][1]
            v = op(cur1, cur2)
            if not result or result[-1][1] != v:
                result.append((t, v))
        return Stepfun(result)

    def __add__(self, other: 'Stepfun') -> 'Stepfun':
        return self._binary_op(other, lambda x, y: x + y)

    def __sub__(self, other: 'Stepfun') -> 'Stepfun':
        return self._binary_op(other, lambda x, y: x - y)

    def __mul__(self, other: 'Stepfun') -> 'Stepfun':
        return self._binary_op(other, lambda x, y: x * y)

    def _compare_op(self, other: 'Stepfun', cmp) -> bool:
        if not isinstance(other, Stepfun):
            raise TypeError("Operand must be Stepfun.")
        times = sorted(set(t for t, _ in self._tv_list) | set(t for t, _ in other._tv_list))
        v1 = self._tv_list
        v2 = other._tv_list
        i1 = i2 = 0
        n1 = len(v1)
        n2 = len(v2)
        cur1 = v1[0][1]
        cur2 = v2[0][1]
        for t in times:
            while i1 + 1 < n1 and v1[i1 + 1][0] <= t:
                i1 += 1
                cur1 = v1[i1][1]
            while i2 + 1 < n2 and v2[i2 + 1][0] <= t:
                i2 += 1
                cur2 = v2[i2][1]
            if not cmp(cur1, cur2):
                return False
        return True

    def __lt__(self, other: 'Stepfun') -> bool:
        return self._compare_op(other, lambda x, y: x < y)

    def __le__(self, other: 'Stepfun') -> bool:
        return self._compare_op(other, lambda x, y: x <= y)

    def __gt__(self, other: 'Stepfun') -> bool:
        return self._compare_op(other, lambda x, y: x > y)

    def __ge__(self, other: 'Stepfun') -> bool:
        return self._compare_op(other, lambda x, y: x >= y)

    def __call__(self, x: Number) -> Number:
        """
        Evaluate the step function at x (right-continuous).
        """
        if x < 0:
            raise ValueError("Stepfun is undefined for negative x")
        tv = self._tv_list
        times = [t for t, v in tv]
        idx = bisect.bisect_right(times, x) - 1
        if idx < 0:
            idx = 0  # For x in [0, first change), returns value at 0
        return tv[idx][1]

    def integrate(self, start: Number, end: Number) -> Number:
        """
        Compute the definite integral of the step function on [start, end).
        Uses __call__ to determine interval values.
        """
        if start < 0 or end < 0:
            raise ValueError("Integration bounds must be >= 0.")
        if start > end:
            raise ValueError("Start must be <= end.")
        if start == end:
            return 0.0

        tv = self._tv_list
        times = [t for t, v in tv]
        # Get all relevant interval points in [start, end], plus start and end
        points = [start]
        for t in times:
            if start < t < end:
                points.append(t)
        points.append(end)
        points.sort()
        total = 0.0
        for i in range(len(points) - 1):
            x0 = points[i]
            x1 = points[i + 1]
            val = self(x0)
            total += (x1 - x0) * val
        return total
