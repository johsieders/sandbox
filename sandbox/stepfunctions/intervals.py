# generated by GPT 4.1, 22.06.2025
# project owner: Johannes Siedersleben
#
# =============================================================================
# Intervals: Fast and General Set Operations on Real Intervals
#
# This class provides a robust, mathematically precise, and efficient toolkit
# for working with sets of real intervals in Python. Intervals are represented
# as unions of left-closed, right-open intervals, with support for both bounded
# and unbounded endpoints. By internally mapping interval lists to a Boolean
# step function (`BoolStepfun`), the class enables users to perform all
# fundamental set operations, efficient evaluation, and canonicalization
# effortlessly.
#
# Key Concepts:
# -------------
# 1. **Interval Representation:**
#    Intervals are specified as tuples of endpoints (left, right). Endpoints can
#    be real numbers, `None`, or the strings '-oo' and 'oo' to indicate
#    unboundedness. For example, `(10, 20)` is the half-open interval [10, 20),
#    `('-oo', 5)` covers all x < 5, and `(0, None)` (or `(0, 'oo')`) covers all
#    x >= 0.
#
# 2. **Internal Mapping and Normalization:**
#    The class translates any collection of possibly overlapping or redundant
#    intervals into a single, canonical Boolean step function. This step
#    function takes the value `True` exactly on the union of the specified
#    intervals, and `False` elsewhere. Construction merges, sorts, and
#    normalizes all intervals, so operations always use the minimal, disjoint
#    set.
#
# 3. **Set Operations:**
#    All set-theoretic operations are provided and overloaded:
#      - `|` for union
#      - `&` for intersection
#      - `-` for set difference
#      - `^` for symmetric difference
#      - unary `-` for complement
#    Bulk operations for N-ary union/intersection are supported via static
#    methods (`Intervals.union(*args)`, `Intervals.intersection(*args)`).
#
# 4. **Comparisons and Subsets:**
#    All six comparison operators are implemented as subset/superset/equality
#    relations: for example, `A <= B` means every point in A is also in B. This
#    enables expressive mathematical logic and ordering of sets of intervals.
#
# 5. **Efficient Evaluation and Conversion:**
#    You can test whether a real number x is in the set by calling the instance
#    as a function: `A(x)` returns `True` if x is in any of the intervals. The
#    `.intervals` property always returns the canonical, sorted list of
#    non-overlapping intervals.
#
# 6. **Performance and Extensibility:**
#    All operations are implemented efficiently by reusing the `BoolStepfun`
#    engine, which merges all change points in O(n) time and provides fast
#    evaluation and normalization. The design is easily extensible for future
#    enhancements (e.g., integer intervals, labeled intervals).
#
# Usage Overview:
# ---------------
# - Construct a set of intervals:
#     A = Intervals([(-5, 0), (10, 20)])
#     B = Intervals([('-oo', -1), (15, None)])
#
# - Set operations:
#     U = A | B                    # union
#     I = A & B                    # intersection
#     D = A - B                    # set difference
#     S = A ^ B                    # symmetric difference
#     C = -A                       # complement
#     BIG = Intervals.union(A, B, C, D, S)   # N-ary union
#
# - Comparison:
#     if A <= B: ...
#
# - Membership and interval list:
#     if A(12.5): ...
#     for left, right in A.intervals: ...
#
# This class, together with `BoolStepfun`, is suitable for interval arithmetic,
# set-theoretic algorithms, event or coverage modeling, and all situations
# where rigorous and efficient handling of real intervals is required.
# =============================================================================

from typing import Iterable, Tuple, Any, List, Optional

from sandbox.stepfunctions.stepfun import BoolStepfun


class Intervals:
    """
    Represents a set of real intervals (possibly unbounded), modeled as a BoolStepfun.
    Supports union (|), intersection (&), difference (-), symmetric difference (^),
    complement (-a), subset/superset/equality comparisons, and efficient N-ary union/intersection.
    """

    def __init__(self, interval_list: Iterable[Tuple[Any, Any]]):
        """
        interval_list: iterable of (left, right) endpoints.
        Each endpoint can be a number, None, or '-oo'/'oo' as strings.
        Intervals are left-closed, right-open unless left-unbounded (in which case left-open).
        """
        self._stepfun = self._intervals_to_stepfun(interval_list)

    @staticmethod
    def _intervals_to_stepfun(interval_list: Iterable[Tuple[Any, Any]]) -> BoolStepfun:
        """
        Converts a list of intervals to a BoolStepfun that is True exactly on those intervals.
        """
        events: List[Tuple[Any, bool]] = []
        for left, right in interval_list:
            # Normalize endpoints
            l = float('-inf') if left in (None, '-oo') else left
            r = float('inf') if right in (None, 'oo') else right
            if l == r:
                continue  # degenerate interval
            if l > r:
                l, r = r, l
            events.append((l, True))  # interval starts: True
            events.append((r, False))  # interval ends: False
        if not events:
            # The empty set
            return BoolStepfun([(None, False)])
        # Sort events: start before stop if at same point
        events.sort(key=lambda e: (e[0], not e[1]))
        # Build step function transitions
        tv: List[Tuple[Optional[float], bool]] = []
        count = 0
        last_val = False
        for x, is_start in events:
            prev_val = count > 0
            count += 1 if is_start else -1
            new_val = count > 0
            if new_val != prev_val:
                tv.append((x if x != float('-inf') else None, new_val))
        # Set initial value for -âˆž
        if not tv or tv[0][0] is not None:
            tv = [(None, False)] + tv
        return BoolStepfun(tv)

    @staticmethod
    def _stepfun_to_intervals(stepfun: BoolStepfun) -> Tuple[Tuple[Any, Any], ...]:
        """
        Converts a BoolStepfun to a canonical sorted tuple of intervals.
        Each interval is (left, right), using None for unbounded ends.
        """
        tv = list(stepfun.tv_list)
        intervals = []
        current = None
        for i, (t, v) in enumerate(tv):
            if v:  # interval starts here
                left = t
                # find where it ends
                for j in range(i + 1, len(tv)):
                    t2, v2 = tv[j]
                    if not v2:
                        right = t2
                        break
                else:
                    right = None  # unbounded right
                # Use None for -inf, oo for infinity
                l = None if left is None else left
                r = None if right is None else right
                intervals.append((l, r))
        return tuple(intervals)

    # Set operations
    def __or__(self, other: "Intervals") -> "Intervals":
        return Intervals.from_stepfun(self._stepfun | other._stepfun)

    def __and__(self, other: "Intervals") -> "Intervals":
        return Intervals.from_stepfun(self._stepfun & other._stepfun)

    def __sub__(self, other: "Intervals") -> "Intervals":
        return Intervals.from_stepfun(self._stepfun & ~other._stepfun)

    def __xor__(self, other: "Intervals") -> "Intervals":
        return Intervals.from_stepfun(self._stepfun ^ other._stepfun)

    def __neg__(self) -> "Intervals":
        return Intervals.from_stepfun(~self._stepfun)

    # Bulk set operations
    @staticmethod
    def union(*intervals: "Intervals") -> "Intervals":
        if not intervals:
            return Intervals([])
        stepfuns = [iv._stepfun for iv in intervals]
        return Intervals.from_stepfun(BoolStepfun.logical_or(*stepfuns))

    @staticmethod
    def intersection(*intervals: "Intervals") -> "Intervals":
        if not intervals:
            return Intervals([])
        stepfuns = [iv._stepfun for iv in intervals]
        return Intervals.from_stepfun(BoolStepfun.logical_and(*stepfuns))

    # Comparison (subset/superset)
    def __le__(self, other: "Intervals") -> bool:
        # self is subset of other iff (self & ~other) is empty
        diff = self - other
        return all(not v for t, v in diff._stepfun.tv_list)

    def __lt__(self, other: "Intervals") -> bool:
        return self <= other and self != other

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, Intervals):
            return NotImplemented
        return self._stepfun == other._stepfun

    def __ne__(self, other: object) -> bool:
        return not self == other

    def __ge__(self, other: "Intervals") -> bool:
        return other <= self

    def __gt__(self, other: "Intervals") -> bool:
        return other < self

    def __str__(self):
        intervals = self._stepfun_to_intervals(self._stepfun)
        return f"Intervals{intervals}"

    def __repr__(self):
        return str(self)

    @property
    def intervals(self) -> Tuple[Tuple[Any, Any], ...]:
        return self._stepfun_to_intervals(self._stepfun)

    @classmethod
    def from_stepfun(cls, sf: BoolStepfun) -> "Intervals":
        obj = cls([])
        obj._stepfun = sf
        return obj

    # Expose underlying BoolStepfun for evaluation
    def __call__(self, x) -> bool:
        return self._stepfun(x)

    # Optional: direct access for test/utility
    @property
    def stepfun(self):
        return self._stepfun

# =============================================================================
