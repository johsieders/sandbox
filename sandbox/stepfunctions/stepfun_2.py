# generated by GPT 4.1, 21.06.2025
# project Owner: Johannes Siedersleben
#
import bisect
import heapq
import operator
from typing import Iterable, Sequence, Tuple, Any, Union, Callable

Timestamp = Union[int, float]
TvPair = Tuple[Timestamp, Any]


def is_number(x) -> bool:
    return isinstance(x, (int, float)) and not isinstance(x, bool)


def merge_timestamps(*tv_lists):
    iterables = [(t for t, _ in tv) for tv in tv_lists]
    merged = heapq.merge(*iterables)
    prev = None
    for t in merged:
        if t != prev:
            yield t
            prev = t


class Stepfun:
    __slots__ = ('_tv_list',)
    _tv_list: Tuple[TvPair, ...]

    def __init__(self, tv_list: Iterable[TvPair] | 'Stepfun'):
        if isinstance(tv_list, Stepfun):
            self._tv_list = tv_list._tv_list
            return
        items = []
        for pair in tv_list:
            if not (isinstance(pair, tuple) and len(pair) == 2):
                raise TypeError("Each tv-pair must be a tuple (timestamp, value).")
            t, v = pair
            if not isinstance(t, (int, float)):
                raise TypeError("Timestamps must be int or float.")
            items.append((float(t), v))
        if not items:
            raise ValueError("tv_list must not be empty.")
        items.sort()
        norm = []
        for t, v in items:
            if norm and norm[-1][0] == t:
                norm[-1] = (t, v)
            else:
                norm.append((t, v))
        merged = []
        for t, v in norm:
            if not merged or merged[-1][1] != v:
                merged.append((t, v))
        if merged[0][0] != 0:
            raise ValueError("tv_list must start at timestamp 0.")
        self._tv_list = tuple(merged)

    @property
    def tv_list(self) -> Tuple[TvPair, ...]:
        return self._tv_list

    def __repr__(self) -> str:
        return f"Stepfun({self._tv_list})"

    def __str__(self) -> str:
        return f"Stepfun{self._tv_list}"

    def __call__(self, x: Timestamp) -> Any:
        if x < 0:
            raise ValueError("Stepfun is undefined for negative x")
        tv = self._tv_list
        times = [t for t, _ in tv]
        idx = bisect.bisect_right(times, x) - 1
        if idx < 0:
            idx = 0
        return tv[idx][1]

    def __neg__(self) -> 'Stepfun':
        def negval(v):
            return -v if is_number(v) else v

        return Stepfun(((t, negval(v)) for t, v in self._tv_list))

    def __abs__(self) -> 'Stepfun':
        def absval(v):
            return abs(v) if is_number(v) else v

        return Stepfun(((t, absval(v)) for t, v in self._tv_list))

    @staticmethod
    def _combine(
            fs: Sequence['Stepfun'],
            op: Callable,
            identity: Any = None,
            left_assoc: bool = False
    ) -> 'Stepfun':
        """
        Generic N-ary combine.
        If left_assoc is False (default): use identity for sum/product.
        If left_assoc is True: use left-to-right reduction, no identity.
        """
        if not fs:
            raise ValueError("At least one step function required.")
        tv_lists = [f._tv_list for f in fs]
        timestamps = list(merge_timestamps(*tv_lists))
        idxs = [0] * len(fs)
        values = [f._tv_list[0][1] for f in fs]
        lengths = [len(f._tv_list) for f in fs]
        result = []
        for t in timestamps:
            for i, tv in enumerate(tv_lists):
                while idxs[i] + 1 < lengths[i] and tv[idxs[i] + 1][0] <= t:
                    idxs[i] += 1
                    values[i] = tv[idxs[i]][1]
            # Excel logic: if any value is non-numeric, propagate the first such value
            for val in values:
                if not is_number(val):
                    v = val
                    break
            else:
                if left_assoc:
                    v = values[0]
                    for val in values[1:]:
                        v = op(v, val)
                else:
                    v = identity
                    for val in values:
                        v = op(v, val)
            if not result or result[-1][1] != v:
                result.append((t, v))
        return Stepfun(result)

    @staticmethod
    def sum(*fs: 'Stepfun') -> 'Stepfun':
        return Stepfun._combine(fs, operator.add, 0, left_assoc=False)

    @staticmethod
    def multiply(*fs: 'Stepfun') -> 'Stepfun':
        return Stepfun._combine(fs, operator.mul, 1, left_assoc=False)

    def __add__(self, other: 'Stepfun') -> 'Stepfun':
        return Stepfun.sum(self, other)

    def __mul__(self, other: 'Stepfun') -> 'Stepfun':
        return Stepfun.multiply(self, other)

    def __sub__(self, other: 'Stepfun') -> 'Stepfun':
        def sub(x, y):
            if not is_number(x):
                return x
            if not is_number(y):
                return y
            return x - y

        return Stepfun._combine([self, other], sub, left_assoc=True)

    def __truediv__(self, other: 'Stepfun') -> 'Stepfun':
        def div(x, y):
            if not is_number(x):
                return x
            if not is_number(y):
                return y
            if y == 0:
                return "DIV/0"
            return x / y

        return Stepfun._combine([self, other], div, left_assoc=True)

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, Stepfun):
            return NotImplemented
        for t in merge_timestamps(self._tv_list, other._tv_list):
            if self(t) != other(t):
                return False
        return True

    def _diff(self, other: 'Stepfun') -> 'Stepfun':
        return self.__sub__(other)

    def __lt__(self, other: 'Stepfun') -> bool:
        diff = self._diff(other)
        for t in merge_timestamps(self._tv_list, other._tv_list):
            v = diff(t)
            if not is_number(v):
                return False
            if v >= 0:
                return False
        return True

    def __le__(self, other: 'Stepfun') -> bool:
        diff = self._diff(other)
        for t in merge_timestamps(self._tv_list, other._tv_list):
            v = diff(t)
            if not is_number(v):
                return False
            if v > 0:
                return False
        return True

    def __gt__(self, other: 'Stepfun') -> bool:
        return other.__lt__(self)

    def __ge__(self, other: 'Stepfun') -> bool:
        return other.__le__(self)

    def integrate(self, start: Timestamp, end: Timestamp) -> float:
        if start < 0 or end < 0:
            raise ValueError("Integration bounds must be >= 0.")
        if start > end:
            raise ValueError("Start must be <= end.")
        if start == end:
            return 0.0
        tv = self._tv_list
        times = [t for t, _ in tv]
        points = [start]
        for t in times:
            if start < t < end:
                points.append(t)
        points.append(end)
        points.sort()
        total = 0.0
        for i in range(len(points) - 1):
            x0 = points[i]
            x1 = points[i + 1]
            val = self(x0)
            if is_number(val):
                total += (x1 - x0) * val
        return total

# End of Stepfun class
