# generated by GPT 4.1, 21.06.2025
# project Owner: Johannes Siedersleben
#
#   A step function is given by a list of (timestamp, value)-pairs, or tv-pairs for short.
#   Examples:
#   ((0, 100),) represents a function that is constant = 100 for 0 <= x < +oo.
#   ((0, 100), 20, 200)) represents a function that is constant = 100 for 0 <= x < 20, and constant = 200 on [20, +oo)
#   We only consider right-continuous step functions defined on [0, +oo).
#   A valid tv-list satisfies four conditions:
#   1) It starts at 0, that is, the first tv-pair is like (0, some_value)
#   2) The values are int or float
#   3) The timestamps are strictly ascending.
#   4) The value changes at every timestamp.
#   An invalid tv-list containing (0, some_value) can be normalized
#   by sorting by timestamps and merging intervals with equal values.
#
#   The class Stepfun does (at least) the following:
#   a) The constructor accepts a tv_list or another Stepfun.
#   b) It overloads unary minus, abs
#   c) It overloads +, -, *, ==, <, <=, >, >=
#   d) it implements integrate(self, from, to) with the usual meaning
#   Note that the timestamps of, say f + g, are the union of the timestamps of f and of g,
#   with some timestamps possibly normalized away.
#   Example:
#   Stepfun(((0,2), (10, 1))) + Stepfun(((0,1), (10, 2))) = Stepfun(((0,3),))
#
#   We allow functions that are undefined or ill-defined on some intervals,
#   which is indicated by a tv-pair like (t, None), or (t, "Hello World") or (t, x)
#   with non-numeric x. Stepfun((0, None)) is a function that is nowhere defined;
#   Stepfun(((0,10), (1, " "), (2, 20))) is Blank on [1,2).
#   The generalized class works exactly as before for numeric values.
#   Non-numeric values are ignored, just as in Excel sheets.
#   With v for a numeric value and x for anything else, we set  x + v = v + x = x
#   and likewise for - and *. We set x < v and x == v to False,
#   and define f < g iff f - g < 0 which can be computed whenever f - g is defined everywhere.
#   If not, both f < g , and f > g are false.
#   Equality makes sense if we apply x == y to any type that implements equality.
#
#   Generated by GPT 4.1
#   20.06.2025

import bisect
from typing import Iterable, Sequence, Tuple, Any, Union

Timestamp = Union[int, float]
TvPair1 = Tuple[Timestamp, Any]
TvList1 = Sequence[TvPair1]


def is_number(x) -> bool:
    return isinstance(x, (int, float)) and not isinstance(x, bool)


class Stepfun:
    """
    Generalized right-continuous step function.
    Values may be numbers, None, or any object.
    Arithmetic is Excel-like: non-numeric means blank/error and propagates.
    Division by zero returns "DIV/0".
    """
    __slots__ = ('_tv_list',)

    _tv_list: Tuple[TvPair1, ...]

    def __init__(self, tv_list: Iterable[TvPair1] | 'Stepfun'):
        if isinstance(tv_list, Stepfun):
            self._tv_list = tv_list._tv_list
            return

        items = []
        for pair in tv_list:
            if not (isinstance(pair, tuple) and len(pair) == 2):
                raise TypeError("Each tv-pair must be a tuple (timestamp, value).")
            t, v = pair
            if not isinstance(t, (int, float)):
                raise TypeError("Timestamps must be int or float.")
            items.append((float(t), v))

        if not items:
            raise ValueError("tv_list must not be empty.")

        # Sort by timestamp, keep last for duplicate t
        items.sort()
        norm = []
        for t, v in items:
            if norm and norm[-1][0] == t:
                norm[-1] = (t, v)
            else:
                norm.append((t, v))

        # Merge consecutive intervals with same value (by equality, not is)
        merged = []
        for t, v in norm:
            if not merged or merged[-1][1] != v:
                merged.append((t, v))
        if merged[0][0] != 0:
            raise ValueError("tv_list must start at timestamp 0.")
        for i in range(1, len(merged)):
            if merged[i][0] <= merged[i - 1][0]:
                raise ValueError("Timestamps must be strictly ascending.")
        self._tv_list = tuple(merged)

    @property
    def tv_list(self) -> Tuple[TvPair1, ...]:
        return self._tv_list

    def __repr__(self) -> str:
        return f"Stepfun({self._tv_list})"

    def __str__(self) -> str:
        return f"Stepfun{self._tv_list}"

    def __call__(self, x: Timestamp) -> Any:
        if x < 0:
            raise ValueError("Stepfun is undefined for negative x")
        tv = self._tv_list
        times = [t for t, _ in tv]
        idx = bisect.bisect_right(times, x) - 1
        if idx < 0:
            idx = 0
        return tv[idx][1]

    # === Arithmetic ===
    def __neg__(self) -> 'Stepfun':
        def negval(v):
            return -v if is_number(v) else v

        return Stepfun(((t, negval(v)) for t, v in self._tv_list))

    def __abs__(self) -> 'Stepfun':
        def absval(v):
            return abs(v) if is_number(v) else v

        return Stepfun(((t, absval(v)) for t, v in self._tv_list))

    def _binary_op(self, other: 'Stepfun', op):
        if not isinstance(other, Stepfun):
            raise TypeError("Operand must be Stepfun_1.")
        times = sorted(set(t for t, _ in self._tv_list) | set(t for t, _ in other._tv_list))
        v1 = self._tv_list
        v2 = other._tv_list
        i1 = i2 = 0
        n1 = len(v1)
        n2 = len(v2)
        cur1 = v1[0][1]
        cur2 = v2[0][1]
        result = []
        for t in times:
            while i1 + 1 < n1 and v1[i1 + 1][0] <= t:
                i1 += 1
                cur1 = v1[i1][1]
            while i2 + 1 < n2 and v2[i2 + 1][0] <= t:
                i2 += 1
                cur2 = v2[i2][1]
            v = op(cur1, cur2)
            if not result or result[-1][1] != v:
                result.append((t, v))
        return Stepfun(result)

    def __add__(self, other: 'Stepfun') -> 'Stepfun':
        def add(x, y):
            if not is_number(x):
                return x
            if not is_number(y):
                return y
            return x + y

        return self._binary_op(other, add)

    def __sub__(self, other: 'Stepfun') -> 'Stepfun':
        def sub(x, y):
            if not is_number(x):
                return x
            if not is_number(y):
                return y
            return x - y

        return self._binary_op(other, sub)

    def __mul__(self, other: 'Stepfun') -> 'Stepfun':
        def mul(x, y):
            if not is_number(x):
                return x
            if not is_number(y):
                return y
            return x * y

        return self._binary_op(other, mul)

    def __truediv__(self, other: 'Stepfun') -> 'Stepfun':
        def div(x, y):
            if not is_number(x):
                return x
            if not is_number(y):
                return y
            if y == 0:
                return "DIV/0"
            return x / y

        return self._binary_op(other, div)

    # === Comparison ===

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, Stepfun):
            return NotImplemented
        # Compare value equality at all (union) change points
        times = sorted(set(t for t, _ in self._tv_list) | set(t for t, _ in other._tv_list))
        for t in times:
            if self(t) != other(t):
                return False
        return True

    def _diff(self, other: 'Stepfun') -> 'Stepfun':
        return self.__sub__(other)

    def __lt__(self, other: 'Stepfun') -> bool:
        diff = self._diff(other)
        times = sorted(set(t for t, _ in self._tv_list) | set(t for t, _ in other._tv_list))
        for t in times:
            v = diff(t)
            if not is_number(v):
                return False  # undefined or error
            if v >= 0:
                return False
        return True

    def __le__(self, other: 'Stepfun') -> bool:
        diff = self._diff(other)
        times = sorted(set(t for t, _ in self._tv_list) | set(t for t, _ in other._tv_list))
        for t in times:
            v = diff(t)
            if not is_number(v):
                return False
            if v > 0:
                return False
        return True

    def __gt__(self, other: 'Stepfun') -> bool:
        return other.__lt__(self)

    def __ge__(self, other: 'Stepfun') -> bool:
        return other.__le__(self)

    # === Integration ===

    def integrate(self, start: Timestamp, end: Timestamp) -> float:
        if start < 0 or end < 0:
            raise ValueError("Integration bounds must be >= 0.")
        if start > end:
            raise ValueError("Start must be <= end.")
        if start == end:
            return 0.0

        tv = self._tv_list
        times = [t for t, _ in tv]
        # Collect all points of interest in [start, end], plus start and end
        points = [start]
        for t in times:
            if start < t < end:
                points.append(t)
        points.append(end)
        points.sort()
        total = 0.0
        for i in range(len(points) - 1):
            x0 = points[i]
            x1 = points[i + 1]
            val = self(x0)
            if is_number(val):
                total += (x1 - x0) * val
        return total
