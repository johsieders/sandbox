# generated by GPT 4.1, 22.06.2025
# project Owner: Johannes Siedersleben
#
# =============================================================================
# Step Functions for Python: Design and Usage
#
# This library provides an efficient, extensible, and mathematically sound
# implementation of right-continuous step functions for Python. A step function
# is a piecewise constant function defined by a finite, ordered list of
# "breakpoints" or (timestamp, value)-pairs. The library supports step
# functions over the entire real line, with arbitrary value types, and exposes
# a clean object-oriented API for both numeric and boolean-valued functions.
#
# Key Concepts:
# -------------
# 1. **Step Function Structure:**
#    A step function is constructed from a list of (timestamp, value) pairs.
#    The function value is constant between timestamps; it "steps" to a new
#    value at each breakpoint. To allow step functions on the whole real line,
#    the first pair may use `None` (or the string "-oo") as timestamp,
#    specifying the value for all x less than the first breakpoint.
#
# 2. **Immutability and Normalization:**
#    Step function objects are immutable. Upon construction, the breakpoint
#    list is normalized: timestamps are sorted, duplicate timestamps are
#    resolved (last value wins), and consecutive identical values are merged.
#    This ensures each step function is in canonical form.
#
# 3. **Evaluation and Arithmetic:**
#    Step functions support fast evaluation at arbitrary points via
#    binary search. For numeric step functions, all standard arithmetic
#    operations (`+`, `-`, `*`, `/`, pointwise comparisons, etc.) are
#    overloaded and behave as expected mathematically. For boolean step
#    functions, logical operations (`&`, `|`, `^`, `~`) and all comparison
#    operators are provided.
#
# 4. **Error Propagation and Value Semantics:**
#    The design allows "undefined" or non-numeric values (e.g., None, str) to
#    be present in a step function. Operations propagate non-numeric values
#    (Excel-style): if any operand at a point is not a valid number/bool, the
#    result at that point is the first such non-numeric encountered.
#
# 5. **Efficient N-ary Operations:**
#    Unlike naÃ¯ve implementations, the library provides efficient static
#    methods (e.g., `sum`, `multiply` for numeric, `logical_and`,
#    `logical_or` for boolean) that combine N step functions in O(n)
#    time by merging their breakpoints in a single pass. This is much faster
#    than chaining binary operations.
#
# 6. **Extensibility via Abstract Base:**
#    All normalization, merging, and evaluation logic is contained in the
#    abstract class `AbstractStepfun`. Value-type-specific subclasses
#    (`NumericStepfun`, `BoolStepfun`) provide appropriate operators and type
#    checks, ensuring type safety and extensibility. The factory method
#    `AbstractStepfun.make_stepfun` inspects a value list and constructs the
#    correct subclass.
#
# 7. **Scan/Discretization Utility:**
#    The `scan` class method enables users to create a step function from any
#    callable over a specified range and step size, making it easy to
#    discretize arbitrary mathematical functions.
#
# Usage Overview:
# ---------------
# - Construct a step function directly:
#     f = NumericStepfun([(None, 1.0), (2, 5.0), (5, 3.0)])
#     g = BoolStepfun([(None, False), (3, True)])
#
# - Or use the factory for automatic type detection:
#     h = AbstractStepfun.make_stepfun([(None, 1), (10, 2)])
#
# - Evaluate at any point:
#     value = f(3.5)
#
# - Arithmetic/logical operations:
#     s = f + h
#     b = g & BoolStepfun([(None, True), (4, False)])
#     m = NumericStepfun.sum(f, h, ...)
#     b_all = BoolStepfun.logical_and(g, ...)
#
# - Discretize a function:
#     sf = AbstractStepfun.scan(lambda x: int(x >= 0), -10, 10, 1)
#
# This library is designed for extensibility, performance, and clarity, enabling
# robust mathematical or logical stepwise modeling in scientific computing,
# simulation, signal processing, and beyond.
# =============================================================================

import bisect
from abc import ABC, abstractmethod
from typing import (
    Iterable, Tuple, Any, Union, Callable, TypeVar
)

Timestamp = Union[int, float, None, str]
TvPair = Tuple[Timestamp, Any]
T = TypeVar('T', bound='AbstractStepfun')


class AbstractStepfun(ABC):
    """
    Abstract base class for step functions (any value type, any domain).
    Implements all logic for:
      - change-point management, normalization
      - evaluation (__call__)
      - merging timestamps
      - scanning/discretizing a function into a step function
    Value-type-specific logic is delegated to subclasses.
    """
    __slots__ = ('_tv_list',)

    _tv_list: Tuple[TvPair, ...]

    def __init__(self, tv_list: Iterable[TvPair] | 'AbstractStepfun'):
        if isinstance(tv_list, AbstractStepfun):
            self._tv_list = tv_list._tv_list
            return

        items = []
        for pair in tv_list:
            if not (isinstance(pair, tuple) and len(pair) == 2):
                raise TypeError("Each tv-pair must be a tuple (timestamp, value).")
            t, v = pair
            if t == "-oo":
                t = None
            if not (isinstance(t, (int, float)) or t is None):
                raise TypeError("Timestamps must be int, float, None, or '-oo'.")
            items.append((t, v))
        if not items:
            raise ValueError("tv_list must not be empty.")
        # Sort: None (or "-oo") always first, then ascending numbers
        items.sort(key=lambda pair: (float('-inf') if pair[0] is None else pair[0]))
        # If first timestamp isn't None, insert (None, value) with same value as first
        if items[0][0] is not None:
            items = [(None, items[0][1])] + items
        # Keep only the last value for duplicate timestamps
        norm = []
        for t, v in items:
            if norm and norm[-1][0] == t:
                norm[-1] = (t, v)
            else:
                norm.append((t, v))
        # Merge consecutive intervals with the same value
        merged = []
        for t, v in norm:
            if not merged or merged[-1][1] != v:
                merged.append((t, v))
        self._tv_list = tuple(merged)

    @property
    def tv_list(self) -> Tuple[TvPair, ...]:
        return self._tv_list

    def __repr__(self) -> str:
        cname = self.__class__.__name__
        return f"{cname}({self._tv_list})"

    def __str__(self) -> str:
        cname = self.__class__.__name__
        return f"{cname}{self._tv_list}"

    def __call__(self, x: Timestamp) -> Any:
        # Evaluate at any real x, using first value for x less than all breakpoints
        tv = self._tv_list
        times = [float('-inf') if t is None else t for t, _ in tv]
        idx = bisect.bisect_right(times, x) - 1
        if idx < 0:
            idx = 0
        return tv[idx][1]

    @classmethod
    def merge_timestamps(cls, *tv_lists):
        # Returns sorted unique timestamps across all lists, with None/"-oo" as -inf
        seen = set()
        all_times = []
        for tv in tv_lists:
            for t, _ in tv:
                norm_t = None if t == "-oo" else t
                if norm_t not in seen:
                    all_times.append(norm_t)
                    seen.add(norm_t)
        return sorted(all_times, key=lambda t: float('-inf') if t is None else t)

    @staticmethod
    def scan(
            f: Callable[[float], Any],
            left_bound: float,
            right_bound: float,
            step: float
    ) -> 'AbstractStepfun':
        """
        Returns a step function (as an instance of the current subclass)
        where timestamps are left_bound + n*step and value is f(left_bound + n*step).
        Domain covers all x in [left_bound, right_bound).
        """
        if step <= 0:
            raise ValueError("Step must be positive.")
        v_prev = None
        n = 0
        x = left_bound
        result = []
        while x < right_bound:
            v = f(x)
            if n == 0 or v != v_prev:
                result.append((x if n > 0 else None, v))
            v_prev = v
            x = left_bound + (n + 1) * step
            n += 1
        return AbstractStepfun.make_stepfun(result)

    @staticmethod
    def make_stepfun(tv_list: Iterable[TvPair]) -> 'AbstractStepfun':
        """
        Factory method: Inspects value types and returns the best subclass.
        - All bools   -> BoolStepfun
        - All numeric -> NumericStepfun
        - Otherwise   -> raise TypeError
        """
        tv_list = list(tv_list)

        def is_bool(x):
            return isinstance(x, bool)

        def is_number(x):
            return isinstance(x, (int, float)) and not isinstance(x, bool)

        values = [v for _, v in tv_list]
        if all(is_bool(v) for v in values):
            return BoolStepfun(tv_list)
        elif all(is_number(v) for v in values):
            return NumericStepfun(tv_list)
        else:
            raise TypeError("Cannot infer value type for step function: must be all bool or all numeric.")

    # --- Abstract operators to be implemented in subclasses ---
    @abstractmethod
    def __add__(self, other):
        ...

    @abstractmethod
    def __mul__(self, other):
        ...

    @abstractmethod
    def __sub__(self, other):
        ...

    @abstractmethod
    def __truediv__(self, other):
        ...

    # Optionally, logical operators, only implemented in BoolStepfun
    def __and__(self, other):
        raise NotImplementedError()

    def __or__(self, other):
        raise NotImplementedError()

    def __xor__(self, other):
        raise NotImplementedError()

    def __invert__(self):
        raise NotImplementedError()

    # Comparison, equality, integrate can remain here, or can be type-specific as needed.
    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, AbstractStepfun):
            return NotImplemented
        # Merge all timestamps for complete comparison, including None/"-oo"
        all_timestamps = self.merge_timestamps(self._tv_list, other._tv_list)
        for t in all_timestamps:
            tx = float('-inf') if t is None else t
            if self(tx) != other(tx):
                return False
        return True

    def integrate(self, start: Timestamp, end: Timestamp) -> float:
        if not isinstance(start, (int, float)) or not isinstance(end, (int, float)):
            raise ValueError("Integration bounds must be numbers.")
        if start > end:
            raise ValueError("Start must be <= end.")
        if start == end:
            return 0.0
        tv = self._tv_list
        times = [float('-inf') if t is None else t for t, _ in tv]
        # Only add change points in (start, end)
        points = [start]
        for t in times:
            if start < t < end:
                points.append(t)
        points.append(end)
        points.sort()
        total = 0.0
        for i in range(len(points) - 1):
            x0 = points[i]
            x1 = points[i + 1]
            val = self(x0)
            if isinstance(val, (int, float)):
                total += (x1 - x0) * val
        return total


# NumericStepfun: a subclass of AbstractStepfun for step functions with numeric values only.
# Implements arithmetic operations and propagates non-numerics (e.g., None or str) as in Excel logic.
# Step function for numeric values only, with full comparison support
# (==, !=, <, <=, >, >=) as well as all arithmetic ops.
# Values must be int or float (bools are NOT allowed).

from typing import Any, Callable, Sequence


class NumericStepfun(AbstractStepfun):
    """
    Step function for numeric values, supporting +, -, *, / and all numeric comparisons.
    """

    def _is_number(self, x) -> bool:
        return isinstance(x, (int, float)) and not isinstance(x, bool)

    @staticmethod
    def _combine(
            fs: Sequence['NumericStepfun'],
            op: Callable,
            identity: Any = None,
            left_assoc: bool = False
    ) -> 'NumericStepfun':
        """
        Combine several NumericStepfuns by merging their change points and applying an operator.
        If left_assoc is False (commutative), use identity and reduce over all values.
        If left_assoc is True (non-commutative), apply op in order (left to right), with no identity.
        Non-numeric values propagate: if any value is non-numeric, it is returned immediately (Excel logic).
        """
        if not fs:
            raise ValueError("At least one step function required.")
        tv_lists = [f._tv_list for f in fs]
        # Merge all timestamps, taking care of None (which always sorts first)
        timestamps = AbstractStepfun.merge_timestamps(*tv_lists)
        idxs = [0] * len(fs)
        lengths = [len(tv) for tv in tv_lists]
        result = []
        for t in timestamps:
            current = []
            for i, tv in enumerate(tv_lists):
                while idxs[i] + 1 < lengths[i] and (
                        float('-inf') if tv[idxs[i] + 1][0] is None else tv[idxs[i] + 1][0]) <= (
                        float('-inf') if t is None else t):
                    idxs[i] += 1
                current.append(tv[idxs[i]][1])
            for val in current:
                if not (isinstance(val, (int, float)) and not isinstance(val, bool)):
                    v = val
                    break
            else:
                if left_assoc:
                    v = current[0]
                    for val in current[1:]:
                        v = op(v, val)
                else:
                    v = functools.reduce(op, current, identity)
            if not result or result[-1][1] != v:
                result.append((t, v))
        return NumericStepfun(result)

    @staticmethod
    def sum(*fs: 'NumericStepfun') -> 'NumericStepfun':
        """Efficiently sum multiple NumericStepfun objects in a single pass."""
        return NumericStepfun._combine(fs, operator.add, 0, left_assoc=False)

    @staticmethod
    def multiply(*fs: 'NumericStepfun') -> 'NumericStepfun':
        """Efficiently multiply multiple NumericStepfun objects in a single pass."""
        return NumericStepfun._combine(fs, operator.mul, 1, left_assoc=False)

    def __add__(self, other: 'NumericStepfun') -> 'NumericStepfun':
        return NumericStepfun.sum(self, other)

    def __mul__(self, other: 'NumericStepfun') -> 'NumericStepfun':
        return NumericStepfun.multiply(self, other)

    def __sub__(self, other: 'NumericStepfun') -> 'NumericStepfun':
        def sub(x, y):
            if not self._is_number(x):
                return x
            if not self._is_number(y):
                return y
            return x - y

        return NumericStepfun._combine([self, other], sub, left_assoc=True)

    def __truediv__(self, other: 'NumericStepfun') -> 'NumericStepfun':
        def div(x, y):
            if not self._is_number(x):
                return x
            if not self._is_number(y):
                return y
            if y == 0:
                return "DIV/0"
            return x / y

        return NumericStepfun._combine([self, other], div, left_assoc=True)

    def __neg__(self) -> 'NumericStepfun':
        def negval(v):
            return -v if self._is_number(v) else v

        return NumericStepfun(((t, negval(v)) for t, v in self._tv_list))

    def __abs__(self) -> 'NumericStepfun':
        def absval(v):
            return abs(v) if self._is_number(v) else v

        return NumericStepfun(((t, absval(v)) for t, v in self._tv_list))

    # --- Numeric comparisons: pointwise, True iff all intervals satisfy the comparison ---

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, NumericStepfun):
            return NotImplemented
        all_timestamps = AbstractStepfun.merge_timestamps(self._tv_list, other._tv_list)
        for t in all_timestamps:
            v1, v2 = self(float('-inf') if t is None else t), other(float('-inf') if t is None else t)
            if v1 != v2:
                return False
        return True

    def __ne__(self, other: Any) -> bool:
        eq = self.__eq__(other)
        if eq is NotImplemented:
            return NotImplemented
        return not eq

    def __lt__(self, other: 'NumericStepfun') -> bool:
        all_timestamps = AbstractStepfun.merge_timestamps(self._tv_list, other._tv_list)
        for t in all_timestamps:
            v1, v2 = self(float('-inf') if t is None else t), other(float('-inf') if t is None else t)
            if not (self._is_number(v1) and self._is_number(v2)):
                return False
            if not v1 < v2:
                return False
        return True

    def __le__(self, other: 'NumericStepfun') -> bool:
        all_timestamps = AbstractStepfun.merge_timestamps(self._tv_list, other._tv_list)
        for t in all_timestamps:
            v1, v2 = self(float('-inf') if t is None else t), other(float('-inf') if t is None else t)
            if not (self._is_number(v1) and self._is_number(v2)):
                return False
            if not v1 <= v2:
                return False
        return True

    def __gt__(self, other: 'NumericStepfun') -> bool:
        all_timestamps = AbstractStepfun.merge_timestamps(self._tv_list, other._tv_list)
        for t in all_timestamps:
            v1, v2 = self(float('-inf') if t is None else t), other(float('-inf') if t is None else t)
            if not (self._is_number(v1) and self._is_number(v2)):
                return False
            if not v1 > v2:
                return False
        return True

    def __ge__(self, other: 'NumericStepfun') -> bool:
        all_timestamps = AbstractStepfun.merge_timestamps(self._tv_list, other._tv_list)
        for t in all_timestamps:
            v1, v2 = self(float('-inf') if t is None else t), other(float('-inf') if t is None else t)
            if not (self._is_number(v1) and self._is_number(v2)):
                return False
            if not v1 >= v2:
                return False
        return True


# End of NumericStepfun


# BoolStepfun: A step function class for boolean values, supporting logical operators
# (&, |, ^, ~) and Python's standard order comparisons (False < True, etc.).

from typing import Any, Callable, Sequence
import operator
import functools


class BoolStepfun(AbstractStepfun):
    """
    Step function for boolean values only.
    Supports logical operators (&, |, ^, ~), pointwise ordering, and N-ary logical operations.
    """

    def _is_bool(self, x) -> bool:
        return isinstance(x, bool)

    @staticmethod
    def _combine(
            fs: Sequence['BoolStepfun'],
            op: Callable,
            left_assoc: bool = False
    ) -> 'BoolStepfun':
        if not fs:
            raise ValueError("At least one step function required.")
        tv_lists = [f._tv_list for f in fs]
        timestamps = AbstractStepfun.merge_timestamps(*tv_lists)
        idxs = [0] * len(fs)
        lengths = [len(tv) for tv in tv_lists]
        result = []
        for t in timestamps:
            current = []
            for i, tv in enumerate(tv_lists):
                while idxs[i] + 1 < lengths[i] and (
                        float('-inf') if tv[idxs[i] + 1][0] is None else tv[idxs[i] + 1][0]) <= (
                        float('-inf') if t is None else t):
                    idxs[i] += 1
                current.append(tv[idxs[i]][1])
            for val in current:
                if not isinstance(val, bool):
                    v = val
                    break
            else:
                if left_assoc:
                    v = current[0]
                    for val in current[1:]:
                        v = op(v, val)
                else:
                    v = functools.reduce(op, current)
            if not result or result[-1][1] != v:
                result.append((t, v))
        return BoolStepfun(result)

    # Logical operators (binary)
    def __and__(self, other: 'BoolStepfun') -> 'BoolStepfun':
        return BoolStepfun._combine([self, other], operator.and_)

    def __or__(self, other: 'BoolStepfun') -> 'BoolStepfun':
        return BoolStepfun._combine([self, other], operator.or_)

    def __xor__(self, other: 'BoolStepfun') -> 'BoolStepfun':
        return BoolStepfun._combine([self, other], operator.xor)

    def __invert__(self) -> 'BoolStepfun':
        return BoolStepfun(((t, not v if isinstance(v, bool) else v) for t, v in self._tv_list))

    # N-ary logical operations
    @staticmethod
    def logical_and(*fs: 'BoolStepfun') -> 'BoolStepfun':
        return BoolStepfun._combine(fs, operator.and_)

    @staticmethod
    def logical_or(*fs: 'BoolStepfun') -> 'BoolStepfun':
        return BoolStepfun._combine(fs, operator.or_)

    # Arithmetic operations raise errors
    def __add__(self, other):
        raise NotImplementedError("Addition not supported for BoolStepfun.")

    def __mul__(self, other):
        raise NotImplementedError("Multiplication not supported for BoolStepfun.")

    def __sub__(self, other):
        raise NotImplementedError("Subtraction not supported for BoolStepfun.")

    def __truediv__(self, other):
        raise NotImplementedError("Division not supported for BoolStepfun.")

    # Comparisons (pointwise, like Python bools)
    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, BoolStepfun):
            return NotImplemented
        all_timestamps = AbstractStepfun.merge_timestamps(self._tv_list, other._tv_list)
        for t in all_timestamps:
            v1, v2 = self(float('-inf') if t is None else t), other(float('-inf') if t is None else t)
            if v1 != v2:
                return False
        return True

    def __ne__(self, other: Any) -> bool:
        eq = self.__eq__(other)
        if eq is NotImplemented:
            return NotImplemented
        return not eq

    def __lt__(self, other: 'BoolStepfun') -> bool:
        all_timestamps = AbstractStepfun.merge_timestamps(self._tv_list, other._tv_list)
        for t in all_timestamps:
            v1, v2 = self(float('-inf') if t is None else t), other(float('-inf') if t is None else t)
            if not (isinstance(v1, bool) and isinstance(v2, bool)):
                return False
            if not v1 < v2:
                return False
        return True

    def __le__(self, other: 'BoolStepfun') -> bool:
        all_timestamps = AbstractStepfun.merge_timestamps(self._tv_list, other._tv_list)
        for t in all_timestamps:
            v1, v2 = self(float('-inf') if t is None else t), other(float('-inf') if t is None else t)
            if not (isinstance(v1, bool) and isinstance(v2, bool)):
                return False
            if not v1 <= v2:
                return False
        return True

    def __gt__(self, other: 'BoolStepfun') -> bool:
        all_timestamps = AbstractStepfun.merge_timestamps(self._tv_list, other._tv_list)
        for t in all_timestamps:
            v1, v2 = self(float('-inf') if t is None else t), other(float('-inf') if t is None else t)
            if not (isinstance(v1, bool) and isinstance(v2, bool)):
                return False
            if not v1 > v2:
                return False
        return True

    def __ge__(self, other: 'BoolStepfun') -> bool:
        all_timestamps = AbstractStepfun.merge_timestamps(self._tv_list, other._tv_list)
        for t in all_timestamps:
            v1, v2 = self(float('-inf') if t is None else t), other(float('-inf') if t is None else t)
            if not (isinstance(v1, bool) and isinstance(v2, bool)):
                return False
            if not v1 >= v2:
                return False
        return True

# End of BoolStepfun
