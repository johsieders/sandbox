# generated by GPT 4.1 15.7.2025

from __future__ import annotations

from typing import Optional, Iterator

from sandbox.py4alg.util.primes import is_prime, inv_mod


class ECpoint:
    """
    Represents a point on the elliptic curve y^2 = x^3 + a*x + b mod p.
    Elements form an Abelian group under point addition.
    """

    def __init__(self, a: int, b: int, p: int, x: Optional[int] = None, y: Optional[int] = None):
        """
        Parameters:
            a, b, p: Curve parameters (p prime, field Fp)
            x, y: Coordinates (if None, represents the point at infinity)
        """
        if p <= 2 or not is_prime(p):
            raise ValueError("p must be an odd prime")
        self.a = a
        self.b = b
        self.p = p
        self.x = x
        self.y = y
        if x is not None and y is not None:
            if not self._on_curve(x, y):
                raise ValueError(f"Point ({x}, {y}) is not on the curve")
        # The "point at infinity" is represented by x=None, y=None

    def _on_curve(self, x: int, y: int) -> bool:
        return (y * y - (x * x * x + self.a * x + self.b)) % self.p == 0

    def is_infinity(self) -> bool:
        return self.x is None and self.y is None

    def _assert_compatible(self, other: ECpoint) -> None:
        if not (self.a == other.a and self.b == other.b and self.p == other.p):
            raise TypeError("Points are not on the same curve")

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, ECpoint):
            return False
        return (self.a == other.a and self.b == other.b and self.p == other.p
                and self.x == other.x and self.y == other.y)

    def __neg__(self) -> ECpoint:
        if self.is_infinity():
            return self
        return ECpoint(self.a, self.b, self.p, self.x, (-self.y) % self.p)

    def __add__(self, other: ECpoint) -> ECpoint:
        self._assert_compatible(other)

        # Handle identity
        if self.is_infinity():
            return other
        if other.is_infinity():
            return self

        p = self.p
        x1, y1 = self.x, self.y
        x2, y2 = other.x, other.y

        # Point doubling
        if x1 == x2 and y1 == y2:
            if y1 == 0:
                return ECpoint(self.a, self.b, p)  # Infinity
            # lambda = (3x1^2 + a) / (2y1) mod p
            num = (3 * x1 * x1 + self.a) % p
            den = inv_mod(2 * y1, p)
        else:
            if x1 == x2:
                return ECpoint(self.a, self.b, p)  # Infinity (vertical line)
            num = (y2 - y1) % p
            den = inv_mod(x2 - x1, p)
        lam = (num * den) % p

        x3 = (lam * lam - x1 - x2) % p
        y3 = (lam * (x1 - x3) - y1) % p
        return ECpoint(self.a, self.b, p, x3, y3)

    def __rmul__(self, k: int) -> ECpoint:
        """Scalar multiplication k * P (by double-and-add)"""
        if not isinstance(k, int):
            raise TypeError("Can only multiply ECPoint by an integer")
        result = ECpoint(self.a, self.b, self.p)  # infinity
        addend = self
        while k:
            if k & 1:
                result = result + addend
            addend = addend + addend
            k >>= 1
        return result

    @classmethod
    def gen_points(cls, a: int, b: int, p: int) -> Iterator[ECpoint]:
        """Yields all points (x, y) on the given curve, including infinity"""
        yield cls(a, b, p)  # The point at infinity
        for x in range(p):
            rhs = (x * x * x + a * x + b) % p
            for y in range(p):
                if (y * y) % p == rhs:
                    yield cls(a, b, p, x, y)

    def __str__(self) -> str:
        if self.is_infinity():
            return f"O (infinity) [y^2 = x^3 + {self.a}x + {self.b} mod {self.p}]"
        return f"({self.x}, {self.y}) on y^2 = x^3 + {self.a}x + {self.b} mod {self.p}"

    def __repr__(self) -> str:
        return f"ECPoint({self.a}, {self.b}, {self.p}, {self.x}, {self.y})"
