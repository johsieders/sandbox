"""
Elliptic Curve Points: A Complete Abelian Group Implementation

This module implements points on elliptic curves over finite fields, forming one of the most
elegant and practically important algebraic structures in modern cryptography and number theory.

MATHEMATICAL FOUNDATION:

An elliptic curve over a finite field F_p is defined by the Weierstrass equation:
    y² = x³ + ax + b (mod p)
where p is an odd prime and the discriminant Δ = -16(4a³ + 27b²) ≠ 0 (mod p) ensures
the curve is non-singular (smooth).

The set of points (x, y) satisfying this equation, together with a special "point at infinity" O,
forms an abelian group under a geometrically motivated addition operation. This group structure
is fundamental to elliptic curve cryptography (ECC) and has deep connections to algebraic
geometry and number theory.

THE POINT AT INFINITY:

The "point at infinity" O serves as the group identity element. Geometrically, it can be
understood as the point where all vertical lines meet in the projective plane. Algebraically,
it's the unique point such that P + O = P for any point P on the curve.

In this implementation, the point at infinity is represented by coordinates (None, None).

GEOMETRIC ADDITION PRINCIPLE:

The group law for elliptic curves has an elegant geometric interpretation:

1. **Point Addition (P ≠ Q)**: To add two distinct points P and Q:
   - Draw the line through P and Q
   - This line intersects the curve at exactly one more point R'
   - The sum P + Q is the reflection of R' across the x-axis: R = (x_R, -y_R)

2. **Point Doubling (P = Q)**: To double a point P:
   - Draw the tangent line to the curve at P
   - This tangent intersects the curve at exactly one more point R'
   - The sum P + P = 2P is the reflection of R' across the x-axis

3. **Addition with Infinity**: O + P = P + O = P for any point P

4. **Inverse Elements**: For any point P = (x, y), its inverse is -P = (x, -y)
   This ensures P + (-P) = O, satisfying the group axiom for inverse elements.

ALGEBRAIC FORMULATION:

The geometric construction translates into explicit formulas. For points P₁ = (x₁, y₁)
and P₂ = (x₂, y₂):

Point Addition (P₁ ≠ P₂):
    λ = (y₂ - y₁) / (x₂ - x₁) mod p
    x₃ = λ² - x₁ - x₂ mod p
    y₃ = λ(x₁ - x₃) - y₁ mod p

Point Doubling (P₁ = P₂, y₁ ≠ 0):
    λ = (3x₁² + a) / (2y₁) mod p
    x₃ = λ² - 2x₁ mod p
    y₃ = λ(x₁ - x₃) - y₁ mod p

Special cases handle vertical lines (leading to the point at infinity) and tangents at
points of order 2 (where y = 0).

GROUP PROPERTIES:

The elliptic curve group satisfies all abelian group axioms:
- **Closure**: P + Q is always a point on the curve
- **Associativity**: (P + Q) + R = P + (Q + R)
- **Identity**: O + P = P + O = P
- **Inverse**: P + (-P) = O
- **Commutativity**: P + Q = Q + P

SCALAR MULTIPLICATION:

Scalar multiplication kP (adding P to itself k times) is implemented using the efficient
double-and-add algorithm, which runs in O(log k) time. This operation is fundamental
to elliptic curve cryptography, where the discrete logarithm problem (given P and kP,
find k) is believed to be computationally hard for properly chosen curves.

CRYPTOGRAPHIC SIGNIFICANCE:

Elliptic curve groups provide the same cryptographic security as traditional systems
(like RSA) but with much smaller key sizes, making them ideal for resource-constrained
environments. The security relies on the elliptic curve discrete logarithm problem
(ECDLP) being computationally intractable.

This implementation provides a mathematically rigorous foundation for understanding
elliptic curves, suitable for both educational purposes and practical cryptographic
applications.
"""

# generated by GPT 4.1 15.7.2025, enhanced with mathematical exposition
# js, mathematical review 28/09/2025

from __future__ import annotations

from typing import Optional, Iterator

from sandbox.py4alg.util.primes import is_prime, inv_mod


class ECpoint:
    """
    Represents a point on the elliptic curve y^2 = x^3 + a*x + b mod p.
    Elements form an Abelian group under point addition.
    """

    def __init__(self, a: int, b: int, p: int, x: Optional[int] = None, y: Optional[int] = None):
        """
        Parameters:
            a, b, p: Curve parameters (p prime, field Fp)
            x, y: Coordinates (if None, represents the point at infinity)
        """
        if p <= 2 or not is_prime(p):
            raise ValueError("p must be an odd prime")
        self.a = a
        self.b = b
        self.p = p
        self.x = x
        self.y = y
        if x is not None and y is not None:
            if not self._on_curve(x, y):
                raise ValueError(f"Point ({x}, {y}) is not on the curve")
        # The "point at infinity" is represented by x=None, y=None

    def _on_curve(self, x: int, y: int) -> bool:
        return (y * y - (x * x * x + self.a * x + self.b)) % self.p == 0

    def is_infinity(self) -> bool:
        return self.x is None and self.y is None

    def _assert_compatible(self, other: ECpoint) -> None:
        if not (self.a == other.a and self.b == other.b and self.p == other.p):
            raise TypeError("Points are not on the same curve")

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, ECpoint):
            return False
        return (self.a == other.a and self.b == other.b and self.p == other.p
                and self.x == other.x and self.y == other.y)

    def __bool__(self) -> bool:
        """Return True if this is not the point at infinity (zero element)."""
        return not self.is_infinity()

    def norm(self) -> float:
        """Return a norm for the point. For infinity, return 0.0."""
        if self.is_infinity():
            return 0.0
        # Use Euclidean distance from origin as a simple norm
        return float((self.x * self.x + self.y * self.y) ** 0.5)

    @classmethod
    def zero(cls) -> 'ECpoint':
        """Return the zero element (point at infinity) with default curve parameters."""
        # Use a default curve y^2 = x^3 + x + 1 mod 7 for the zero element
        return cls(1, 1, 7)

    def __neg__(self) -> ECpoint:
        if self.is_infinity():
            return self
        return ECpoint(self.a, self.b, self.p, self.x, (-self.y) % self.p)

    def __sub__(self, other: ECpoint) -> ECpoint:
        """Subtraction is addition with the negative."""
        return self + (-other)

    def __add__(self, other: ECpoint) -> ECpoint:
        self._assert_compatible(other)

        # Handle identity
        if self.is_infinity():
            return other
        if other.is_infinity():
            return self

        p = self.p
        x1, y1 = self.x, self.y
        x2, y2 = other.x, other.y

        # Point doubling
        if x1 == x2 and y1 == y2:
            if y1 == 0:
                return ECpoint(self.a, self.b, p)  # Infinity
            # lambda = (3x1^2 + a) / (2y1) mod p
            num = (3 * x1 * x1 + self.a) % p
            den = inv_mod(2 * y1, p)
        else:
            if x1 == x2:
                return ECpoint(self.a, self.b, p)  # Infinity (vertical line)
            num = (y2 - y1) % p
            den = inv_mod(x2 - x1, p)
        lam = (num * den) % p

        x3 = (lam * lam - x1 - x2) % p
        y3 = (lam * (x1 - x3) - y1) % p
        return ECpoint(self.a, self.b, p, x3, y3)

    def __rmul__(self, k: int) -> ECpoint:
        """Scalar multiplication k * P (by double-and-add)"""
        if not isinstance(k, int):
            raise TypeError("Can only multiply ECPoint by an integer")

        # Handle edge cases
        if k == 0:
            return ECpoint(self.a, self.b, self.p)  # infinity
        if k < 0:
            return (-k) * (-self)

        result = ECpoint(self.a, self.b, self.p)  # infinity
        addend = self

        while k > 0:  # Changed from 'while k:' to 'while k > 0:' for clarity
            if k & 1:
                result = result + addend
            if k > 1:  # Only double if we're not at the last bit
                addend = addend + addend
            k >>= 1
        return result

    @classmethod
    def gen_points(cls, a: int, b: int, p: int) -> Iterator[ECpoint]:
        """Yields all points (x, y) on the given curve, including infinity"""
        yield cls(a, b, p)  # The point at infinity
        for x in range(p):
            rhs = (x * x * x + a * x + b) % p
            for y in range(p):
                if (y * y) % p == rhs:
                    yield cls(a, b, p, x, y)

    def __str__(self) -> str:
        if self.is_infinity():
            return f"O (infinity) [y^2 = x^3 + {self.a}x + {self.b} mod {self.p}]"
        return f"({self.x}, {self.y}) on y^2 = x^3 + {self.a}x + {self.b} mod {self.p}"

    def __repr__(self) -> str:
        return f"ECPoint({self.a}, {self.b}, {self.p}, {self.x}, {self.y})"
