# generated by GPT 4.1
# 15.7.2025

import itertools

from enigma.machine import EnigmaMachine


def all_rotor_positions():
    """Yield all possible rotor positions as ('A','A','A') ... ('Z','Z','Z')."""
    letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    for pos in itertools.product(letters, repeat=3):
        yield ''.join(pos)


def all_plugboard_pairs(letters='ABCDEFGHIJKLMNOPQRSTUVWXYZ', num_pairs=6):
    """Yield all possible plugboard settings with num_pairs swapped pairs (combinatorially huge, so use carefully!)"""
    for pairs in itertools.combinations(itertools.combinations(letters, 2), num_pairs):
        used = set()
        plug = []
        for a, b in pairs:
            if a in used or b in used:
                break
            plug.append(a + b)
            used.add(a)
            used.add(b)
        else:
            yield ' '.join(plug)


def decode(crib_plain, crib_cipher, rotors=['I', 'II', 'III'], ring_settings='AAA', plug_pairs=None, max_plugs=1):
    """
    Brute-force the Enigma settings to find the correct initial rotor positions and plugboard
    to map crib_plain to crib_cipher. Returns (rotor_pos, plugboard_setting)
    """
    letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    results = []
    # Try all rotor starting positions
    for rotor_pos in all_rotor_positions():
        # Try plugboard settings (here just 0 or 1 swap for speed)
        plug_settings = ['']  # no plugs
        if plug_pairs:
            plug_settings += plug_pairs
        else:
            if max_plugs > 0:
                # Try all single plug swaps for demonstration (real Enigma used 6-10)
                for pair in itertools.combinations(letters, 2):
                    plug_settings.append(f"{pair[0]}{pair[1]}")
        for plugboard in plug_settings:
            machine = EnigmaMachine.from_key_sheet(
                rotors=rotors,
                reflector='B',
                ring_settings=ring_settings,
                plugboard_settings=plugboard
            )
            machine.set_display(rotor_pos)
            # Encrypt crib_plain and compare
            output = machine.process_text(crib_plain)
            if output == crib_cipher:
                results.append((rotor_pos, plugboard))
    return results


# --- Example usage ---

crib_plain = "WETTERBERICHT"
crib_cipher = "KCHDOFUIWHZBXY"  # Replace with your actual ciphertext!
rotors = ['I', 'II', 'III']  # Fixed rotor order for this example

results = decode(crib_plain, crib_cipher, rotors=rotors, max_plugs=1)
for rotor_pos, plugboard in results:
    print(f"Rotor positions: {rotor_pos}, Plugboard: {plugboard}")
