# generated by GPT 4.1, 23.06.2025
# project owner: Johannes Siedersleben
#
# =============================================================================
# BoolStepfun Property-Based/Axiomatic Test Suite
#
# This test driver validates the core invariants and logical laws of BoolStepfun
# using property-based, axiom-driven testing. Instead of relying on explicit
# expected values, it generates a set of simple and randomized BoolStepfuns,
# then checks that all logical operations satisfy classic boolean algebra laws,
# such as idempotency, commutativity, associativity, distributivity,
# absorption, De Morgan's laws, involution, and neutral elements.
#
# Each test checks sampled points (including boundaries and random values)
# to ensure correctness for all possible value transitions and edge cases.
#
# Invariants tested include:
# - Idempotency: f & f == f, f | f == f, f ^ f == False, f ^ False == f
# - Commutativity: f & g == g & f, f | g == g | f, f ^ g == g ^ f
# - Associativity: (f & g) & h == f & (g & h), etc.
# - Distributivity: f & (g | h) == (f & g) | (f & h), etc.
# - Neutral elements: f & True == f, f | False == f
# - Absorption: f & (f | g) == f, f | (f & g) == f
# - De Morgan's Laws: ~(f & g) == ~f | ~g, ~(f | g) == ~f & ~g
# - Involution: ~~f == f
# - Symmetric difference: f ^ g == (f & ~g) | (~f & g)
# - Order: f == f, antisymmetry, etc.
# =============================================================================

import random

import pytest

from sandbox.stepfunctions.stepfun import BoolStepfun


def make_simple_boolstepfuns():
    return [
        BoolStepfun([(None, False)]),
        BoolStepfun([(None, True)]),
        BoolStepfun([(None, False), (1, True)]),
        BoolStepfun([(None, True), (2, False)]),
        BoolStepfun([(None, True), (3, True)]),  # constant
        BoolStepfun([(None, False), (0, True), (5, False)]),
    ]


def make_random_boolstepfuns(N, M=5, seed=None):
    if seed is not None:
        random.seed(seed)
    funs = []
    for _ in range(N):
        stamps = sorted(random.sample(range(-100, 101), M))
        values = [random.choice([True, False]) for _ in range(M)]
        tv = [(stamps[0] if i == 0 else stamps[i], values[i]) for i in range(M)]
        tv[0] = (None, tv[0][1])
        funs.append(BoolStepfun(tv))
    return funs


simple_funs = make_simple_boolstepfuns()
big_funs = make_random_boolstepfuns(10, 20, seed=123)
all_funs = simple_funs + big_funs


def sample_points():
    # Wide spread to catch all intervals
    return [-150, -100, -1, 0, 1, 10, 20, 42, 100, 200]


def bool_eq(f, g):
    """True iff f(x) == g(x) for all sample points."""
    pts = sample_points()
    return all(f(x) == g(x) for x in pts)


@pytest.mark.parametrize("f", all_funs)
def test_idempotency(f):
    # f & f == f, f | f == f, f ^ f == False, f ^ False == f
    falsefun = BoolStepfun([(None, False)])
    assert bool_eq(f & f, f)
    assert bool_eq(f | f, f)
    assert bool_eq(f ^ f, falsefun)
    assert bool_eq(f ^ falsefun, f)


@pytest.mark.parametrize("f", all_funs)
@pytest.mark.parametrize("g", all_funs)
def test_commutativity(f, g):
    assert bool_eq(f & g, g & f)
    assert bool_eq(f | g, g | f)
    assert bool_eq(f ^ g, g ^ f)


@pytest.mark.parametrize("f", all_funs)
@pytest.mark.parametrize("g", all_funs)
@pytest.mark.parametrize("h", all_funs)
def test_associativity(f, g, h):
    assert bool_eq((f & g) & h, f & (g & h))
    assert bool_eq((f | g) | h, f | (g | h))
    assert bool_eq((f ^ g) ^ h, f ^ (g ^ h))


@pytest.mark.parametrize("f", all_funs)
@pytest.mark.parametrize("g", all_funs)
@pytest.mark.parametrize("h", all_funs)
def test_distributivity(f, g, h):
    # f & (g | h) == (f & g) | (f & h)
    assert bool_eq(f & (g | h), (f & g) | (f & h))
    # f | (g & h) == (f | g) & (f | h)
    assert bool_eq(f | (g & h), (f | g) & (f | h))


@pytest.mark.parametrize("f", all_funs)
def test_neutral_elements(f):
    # f & True == f, f | False == f
    truefun = BoolStepfun([(None, True)])
    falsefun = BoolStepfun([(None, False)])
    assert bool_eq(f & truefun, f)
    assert bool_eq(f | falsefun, f)


@pytest.mark.parametrize("f", all_funs)
@pytest.mark.parametrize("g", all_funs)
def test_absorption(f, g):
    # f & (f | g) == f, f | (f & g) == f
    assert bool_eq(f & (f | g), f)
    assert bool_eq(f | (f & g), f)


@pytest.mark.parametrize("f", all_funs)
@pytest.mark.parametrize("g", all_funs)
def test_demorgan(f, g):
    # ~(f & g) == ~f | ~g, ~(f | g) == ~f & ~g
    assert bool_eq(~(f & g), (~f) | (~g))
    assert bool_eq(~(f | g), (~f) & (~g))


@pytest.mark.parametrize("f", all_funs)
def test_involution(f):
    # ~~f == f
    assert bool_eq(~(~f), f)


@pytest.mark.parametrize("f", all_funs)
@pytest.mark.parametrize("g", all_funs)
def test_symmetric_difference(f, g):
    # f ^ g == (f & ~g) | (~f & g)
    assert bool_eq(f ^ g, (f & ~g) | (~f & g))


@pytest.mark.parametrize("f", all_funs)
def test_equality_and_order(f):
    # f == f (reflexivity)
    assert bool_eq(f, f)
    # antisymmetry for pointwise order
    pts = sample_points()
    for g in all_funs:
        less = all((not f(x)) and g(x) for x in pts)
        greater = all(f(x) and (not g(x)) for x in pts)
        eq = all(f(x) == g(x) for x in pts)
        if less:
            assert not greater and not eq
        if eq:
            assert not less and not greater

# To run: pytest test_boolstepfun_axioms.py
