# generated by GPT 4.1, 23.06.2025
# project owner: Johannes Siedersleben
#
# =============================================================================
# Stepfun Axiomatic/Invariant-Based Test Suite
#
# This test driver for NumericStepfun (and, with small changes, BoolStepfun)
# is based on the idea of *property-based* or *axiomatic* testing. Rather than
# hard-coding expected results for specific cases, we generate step functions
# (constant, edge, random, and composite examples) and check that their
# mapper and analytical properties (ring/field axioms and theorems) are
# satisfied. This covers much broader ground, catches subtle implementation
# bugs, and is robust against minor expected-value errors due to
# floating-point computation. All equality is checked via a custom `close_to`
# predicate with tolerance epsilon (default 1e-9), ensuring stability for
# numerical code.
#
# Invariants/Axioms tested include:
# - Idempotency: f + f ≈ 2*f, f - f ≈ 0, f * f ≈ f^2, etc.
# - Commutativity: f + g ≈ g + f, f * g ≈ g * f
# - Associativity: (f + g) + h ≈ f + (g + h), etc.
# - Distributivity: f * (g + h) ≈ f*g + f*h
# - Identity and Zero: f + 0 ≈ f, f * 1 ≈ f, f * 0 ≈ 0
# - Negation: f + (-f) ≈ 0
# - Scalar multiplication: f * c ≈ f + ... + f (c times) [with constant function]
# - Comparison/Order: Reflexivity, antisymmetry, trichotomy
# - Triangle inequality: |f+g| ≤ |f| + |g|
# - Integration: linearity over the interval
#
# All tests use sampling and "numerical closeness" rather than strict equality.
# =============================================================================

import random

import math
import pytest

from sandbox.stepfunctions.stepfun import NumericStepfun


def make_simple_stepfuns():
    return [
        NumericStepfun([(None, 0)]),
        NumericStepfun([(None, 1)]),
        NumericStepfun([(None, 0), (1, 2)]),
        NumericStepfun([(None, -5), (0, 0), (10, 5)]),
        NumericStepfun([(None, 7), (2, 7)]),  # constant
        NumericStepfun([(None, 2), (2, 3), (3, 2)]),
    ]


def make_random_stepfuns(N, M=5, seed=None):
    if seed is not None:
        random.seed(seed)
    funs = []
    for _ in range(N):
        stamps = sorted(random.sample(range(-100, 101), M))
        values = [random.uniform(-10, 10) for _ in range(M)]
        tv = [(stamps[0] if i == 0 else stamps[i], values[i]) for i in range(M)]
        tv[0] = (None, tv[0][1])
        funs.append(NumericStepfun(tv))
    return funs


simple_funs = make_simple_stepfuns()
big_funs = make_random_stepfuns(10, 20, seed=42)
all_funs = simple_funs + big_funs


def sample_points():
    # Wide spread to catch all intervals
    return [-150, -100, -1, 0, 1, 10, 20, 42, 100, 200]


def close_to(f, g, eps=1e-9):
    """True iff f(x) ≈ g(x) for all sample points."""
    pts = sample_points()
    for x in pts:
        try:
            v1 = f(x)
            v2 = g(x)
            # Only compare numbers, skip non-numeric
            if isinstance(v1, (int, float)) and isinstance(v2, (int, float)):
                if abs(v1 - v2) > eps:
                    return False
            elif v1 != v2:
                return False
        except Exception:
            continue  # skip points where evaluation fails (e.g. undefined)
    return True


@pytest.mark.parametrize("f", all_funs)
def test_idempotency(f):
    zero = NumericStepfun([(None, 0)])
    two = NumericStepfun([(None, 2)])
    one = NumericStepfun([(None, 1)])
    assert close_to(f + f, f * two)
    assert close_to(f - f, zero)
    assert close_to(f * f, f * f)
    assert close_to(f + zero, f)
    assert close_to(f * one, f)
    assert close_to(f * zero, zero)
    assert close_to(f + (-f), zero)


@pytest.mark.parametrize("f", all_funs)
@pytest.mark.parametrize("g", all_funs)
def test_commutativity(f, g):
    assert close_to(f + g, g + f)
    assert close_to(f * g, g * f)


@pytest.mark.parametrize("f", all_funs)
@pytest.mark.parametrize("g", all_funs)
@pytest.mark.parametrize("h", all_funs)
def test_associativity(f, g, h):
    assert close_to((f + g) + h, f + (g + h))
    assert close_to((f * g) * h, f * (g * h))


@pytest.mark.parametrize("f", all_funs)
@pytest.mark.parametrize("g", all_funs)
@pytest.mark.parametrize("h", all_funs)
def test_distributivity(f, g, h):
    assert close_to(f * (g + h), (f * g) + (f * h))


@pytest.mark.parametrize("f", all_funs)
@pytest.mark.parametrize("g", all_funs)
def test_subtract_inverse(f, g):
    assert close_to(f - g, f + (-g))


@pytest.mark.parametrize("f", all_funs)
def test_abs_square(f):
    # |f| * |f| == f*f (up to sign)
    assert close_to(abs(f) * abs(f), f * f)


@pytest.mark.parametrize("f", all_funs)
def test_negation(f):
    zero = NumericStepfun([(None, 0)])
    assert close_to(f + (-f), zero)


@pytest.mark.parametrize("f", all_funs)
def test_scalar_multiplication(f):
    # f*2 == f+f, f*3 == f+f+f (with constant stepfun, not int)
    two = NumericStepfun([(None, 2)])
    three = NumericStepfun([(None, 3)])
    assert close_to(f * two, f + f)
    assert close_to(f * three, f + f + f)


@pytest.mark.parametrize("f", all_funs)
@pytest.mark.parametrize("g", all_funs)
def test_equality_and_order(f, g):
    # Reflexivity, antisymmetry, trichotomy (for sampled points)
    assert close_to(f, f)
    pts = sample_points()
    less = all((f(x) < g(x)) for x in pts if isinstance(f(x), (int, float)) and isinstance(g(x), (int, float)))
    greater = all((g(x) < f(x)) for x in pts if isinstance(f(x), (int, float)) and isinstance(g(x), (int, float)))
    eq = all(abs(f(x) - g(x)) < 1e-9 for x in pts if isinstance(f(x), (int, float)) and isinstance(g(x), (int, float)))
    if less:
        assert not greater and not eq
    if eq:
        assert not less and not greater


@pytest.mark.parametrize("f", all_funs)
@pytest.mark.parametrize("g", all_funs)
@pytest.mark.parametrize("h", all_funs)
def test_triangle_inequality(f, g, h):
    # |f+g| <= |f| + |g| at each point
    pts = sample_points()
    for x in pts:
        v_fg = abs((f + g)(x))
        v_f = abs(f(x))
        v_g = abs(g(x))
        if all(isinstance(v, (int, float)) for v in [v_fg, v_f, v_g]):
            assert v_fg <= v_f + v_g + 1e-9  # allow tiny overshoot


@pytest.mark.parametrize("f", all_funs)
def test_integration_linear(f):
    a, b = -10, 10
    intf = f.integrate(a, b)
    int2f = (f + f).integrate(a, b)
    assert math.isclose(int2f, 2 * intf, rel_tol=1e-9)

# To run: pytest test_stepfun_axioms.py
