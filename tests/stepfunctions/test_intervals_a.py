# generated by GPT 4.1, 22.06.2025
# project Owner: Johannes Siedersleben
#
# test_intervals_a.py
# Exhaustive test driver for Intervals, including union/intersection (bulk and binary),
# edge cases, complements, differences, subset logic, and performance with randomized data.
# Uses pytest and pytest-benchmark.

import random

import pytest

from sandbox.stepfunctions.intervals import Intervals
from sandbox.stepfunctions.stepfun import BoolStepfun


def test_transformation():
    f = BoolStepfun(((None, False),))
    iv = Intervals.from_stepfun(f)

    v = Intervals([])
    pass


def canonicalize(iv):
    # Returns a sorted tuple of intervals, each as (left, right)
    return tuple(
        sorted((float('-inf') if l in (None, '-oo') else l, float('inf') if r in (None, 'oo') else r) for l, r in iv))


def intervals_are_equal(iv1, iv2):
    return canonicalize(iv1) == canonicalize(iv2)


def test_single_interval():
    I = Intervals([(-5, 0)])
    assert intervals_are_equal(I.intervals, [(-5, 0)])
    # Outside the interval
    assert not I._stepfun(-10)
    assert I._stepfun(-4.9999)
    assert not I._stepfun(0)


def test_union_and_intersection_simple():
    I1 = Intervals([(-5, 0)])
    I2 = Intervals([(0, 5)])
    Iu = I1 | I2
    assert intervals_are_equal(Iu.intervals, [(-5, 5)])
    Ii = I1 & I2
    assert intervals_are_equal(Ii.intervals, [])
    # Overlapping
    I3 = Intervals([(-1, 4)])
    Iu2 = I2 | I3
    assert intervals_are_equal(Iu2.intervals, [(-1, 5)])
    Ii2 = I2 & I3
    assert intervals_are_equal(Ii2.intervals, [(0, 4)])


def test_difference_and_symmetric_difference():
    I = Intervals([(-5, 10), (20, 25)])
    J = Intervals([(8, 30)])
    diff = I - J
    # (-5,8) is left, (20,25)-(20,30) is empty
    assert intervals_are_equal(diff.intervals, [(-5, 8)])
    sym = I ^ J
    # (-5,8),(10,20),(25,30)
    assert intervals_are_equal(sym.intervals, [(-5, 8), (10, 20), (25, 30)])


def test_complement():
    I = Intervals([(-5, 0), (2, 4)])
    comp = -I
    # (-inf, -5), (0,2), (4,inf)
    expected = [('-oo', -5), (0, 2), (4, 'oo')]
    # Allow float('-inf')/float('inf') or '-oo'/'oo'
    c = [((None if l in ('-oo', float('-inf')) else l), (None if r in ('oo', float('inf')) else r)) for l, r in
         expected]
    assert intervals_are_equal(comp.intervals, c)


def test_comparisons():
    I = Intervals([(-5, 0), (10, 20)])
    J = Intervals([(-5, 0), (10, 15)])
    K = Intervals([(-5, 0), (10, 20)])
    assert J < I
    assert not I < J
    assert J <= I
    assert I == K
    assert I != J
    assert I >= J
    assert I > J


def test_from_stepfun_and_str():
    bsf = BoolStepfun([(None, False), (2, True), (5, False)])
    I = Intervals.from_stepfun(bsf)
    assert isinstance(I, Intervals)
    s = str(I)
    assert "Intervals" in s


def test_union_bulk_and_intersection_bulk():
    I1 = Intervals([(-5, 0)])
    I2 = Intervals([(2, 5)])
    I3 = Intervals([(0, 4)])
    all_u = Intervals.union(I1, I2, I3)
    all_i = Intervals.intersection(I1, I3)
    # Union should cover (-5,0), (0,4), (2,5)
    # Intersection of I1 and I3: (0,0) degenerate (empty)
    assert intervals_are_equal(all_u.intervals, [(-5, 5)])
    assert intervals_are_equal(all_i.intervals, [])


@pytest.mark.parametrize("N", [10, 100, 500])
def test_union_performance(N, benchmark):
    def make_random_intervals(n, seed=None):
        if seed is not None:
            random.seed(seed)
        intervals = []
        points = sorted(random.sample(range(-100, 101), 2 * n))
        for i in range(n):
            l, r = points[2 * i], points[2 * i + 1]
            if l == r:
                r += 1
            if l > r:
                l, r = r, l
            intervals.append((l, r))
        return intervals

    interval_objs = [Intervals(make_random_intervals(5, seed=i)) for i in range(N)]

    def do_union():
        U = Intervals.union(*interval_objs)
        for _ in range(5):
            x = random.uniform(-110, 110)
            U._stepfun(x)

    benchmark(do_union)


@pytest.mark.parametrize("N", [10, 100, 500])
def test_intersection_performance(N, benchmark):
    def make_random_intervals(n, seed=None):
        if seed is not None:
            random.seed(seed)
        intervals = []
        points = sorted(random.sample(range(-100, 101), 2 * n))
        for i in range(n):
            l, r = points[2 * i], points[2 * i + 1]
            if l == r:
                r += 1
            if l > r:
                l, r = r, l
            intervals.append((l, r))
        return intervals

    interval_objs = [Intervals(make_random_intervals(5, seed=i)) for i in range(N)]

    def do_intersection():
        I = Intervals.intersection(*interval_objs)
        for _ in range(5):
            x = random.uniform(-110, 110)
            I._stepfun(x)

    benchmark(do_intersection)


def test_edge_cases_and_unbounded():
    # Unbounded intervals
    I = Intervals([('-oo', 0), (10, None)])
    # Should cover all x<0 and x>=10
    assert I._stepfun(-1000)
    assert not I._stepfun(5)
    assert I._stepfun(11)
    # All
    Iall = Intervals([('-oo', None)])
    assert all(Iall._stepfun(x) for x in [-1e10, 0, 1e10])
    # Empty
    Iempty = Intervals([])
    assert not any(Iempty._stepfun(x) for x in [-1e10, 0, 1e10])

# To run: pytest test_intervals_a.py --benchmark-enable
