# generated by GPT 4.1, 22.06.2025
# project Owner: Johannes Siedersleben
#
# This test driver verifies the correctness and robustness of the Intervals class
# by checking the fundamental axioms and theorems of set theory, rather than relying
# on hard-coded expected outputs. Each test reflects a mathematical law that should
# always be satisfied by sets of intervals under standard set operations.
#
# Key Ideas:
# ----------
# - **Property-based Testing:** Instead of specific "input → expected output" pairs,
#   these tests generate a variety of interval sets (including edge cases, random
#   unions, and degenerate intervals) and check universal properties like
#   commutativity, associativity, distributivity, De Morgan's laws, idempotency,
#   absorption, and the correct behavior of complements and subset relations.
#
# - **Axiom-Driven:** Each test encodes a core axiom or "theorem" of set algebra,
#   ensuring that Intervals supports union, intersection, difference, symmetric
#   difference, and complement in a mathematically sound way.
#
# - **Robust Coverage:** By parameterizing tests over simple, edge-case, and
#   randomly-generated interval sets, the suite is highly effective at catching
#   subtle implementation bugs, edge cases, or future regressions—often more so
#   than expected-value tests alone.
#
# - **Maintainability:** New axioms or set-theoretic properties can be easily
#   added as tests. The test suite serves as executable mathematical
#   documentation for the Intervals API.
#
# Invariants tested include (but are not limited to):
# - Idempotency, commutativity, associativity, distributivity
# - De Morgan's laws
# - Absorption and double negation
# - Subset and equality relations
# - Symmetric difference and complements
# - Neutral elements (empty and universal sets)
#
# For each axiom, tests are parameterized by a broad variety of interval sets.
# This approach provides high mathematical confidence in the implementation.
#
# To run:
#   pytest test_intervals_axioms.py
# =============================================================================


import random

import pytest

from sandbox.stepfunctions.intervals import Intervals


# test_intervals_axioms.py
# Tests for Intervals based on axioms and theorems, using invariants.
# Pytest compatible. Add/extend as you see fit.


def generate_simple_intervals():
    # Edge and simple cases
    return [
        Intervals([]),  # empty set
        Intervals([('-oo', None)]),  # the full line
        Intervals([(-5, 5)]),
        Intervals([(0, 1)]),
        Intervals([(-10, -5), (5, 10)]),
        Intervals([(0, 0)]),  # degenerate (empty)
        Intervals([(5, -5)]),  # reversed endpoints
        Intervals([('-oo', 0), (1, 2), (3, None)]),
    ]


def generate_random_intervals(N, M=5, seed=None):
    # Generate N Intervals, each is a union of M random intervals in [-100,100]
    if seed is not None:
        random.seed(seed)
    objs = []
    for i in range(N):
        pts = sorted(random.sample(range(-100, 101), 2 * M))
        lst = []
        for j in range(M):
            a, b = pts[2 * j], pts[2 * j + 1]
            if a == b:
                b += 1
            if a > b:
                a, b = b, a
            lst.append((a, b))
        objs.append(Intervals(lst))
    return objs


# Collect all test objects
simple_objs = generate_simple_intervals()
big_objs = generate_random_intervals(10, 20, seed=42)  # 10 objects, each 20 intervals
all_objs = simple_objs + big_objs


@pytest.mark.parametrize("A", all_objs)
def test_idempotency(A):
    # A | A == A, A & A == A, A - A == empty, A ^ A == empty, --A == A
    assert (A | A) == A
    assert (A & A) == A
    assert (A - A).intervals == ()
    assert (A ^ A).intervals == ()
    assert (-(-A)) == A


@pytest.mark.parametrize("A", all_objs)
@pytest.mark.parametrize("B", all_objs)
def test_commutativity_and_subset(A, B):
    # A | B == B | A; A & B == B & A; A | B >= A, A & B <= A
    assert (A | B) == (B | A)
    assert (A & B) == (B & A)
    assert (A | B) >= A
    assert (A & B) <= A


@pytest.mark.parametrize("A", all_objs)
@pytest.mark.parametrize("B", all_objs)
def test_absorption(A, B):
    # A | (A & B) == A, A & (A | B) == A
    assert (A | (A & B)) == A
    assert (A & (A | B)) == A


@pytest.mark.parametrize("A", all_objs)
@pytest.mark.parametrize("B", all_objs)
def test_demorgan(A, B):
    # - (A | B) == (-A) & (-B), - (A & B) == (-A) | (-B)
    assert - (A | B) == ((-A) & (-B))
    assert - (A & B) == ((-A) | (-B))


@pytest.mark.parametrize("A", all_objs)
@pytest.mark.parametrize("B", all_objs)
@pytest.mark.parametrize("C", all_objs)
def test_associativity(A, B, C):
    # (A | B) | C == A | (B | C)
    # (A & B) & C == A & (B & C)
    assert ((A | B) | C) == (A | (B | C))
    assert ((A & B) & C) == (A & (B & C))


@pytest.mark.parametrize("A", all_objs)
@pytest.mark.parametrize("B", all_objs)
def test_difference_and_symmetric_difference(A, B):
    # (A - B) | (A & B) == A | (B - A) | (A & B) == A | B
    # (A ^ B) == (A - B) | (B - A)
    left = (A - B) | (A & B)
    right = A
    assert left >= right
    assert (A ^ B) == ((A - B) | (B - A))


@pytest.mark.parametrize("A", all_objs)
def test_universe_and_empty(A):
    # A | empty == A, A & full == A, A & empty == empty, A | full == full
    empty = Intervals([])
    full = Intervals([('-oo', None)])
    assert (A | empty) == A
    assert (A & full) == A
    assert (A & empty).intervals == ()
    assert (A | full) == full


@pytest.mark.parametrize("A", all_objs)
def test_complement_and_membership(A):
    # For any x, A(x) != (-A)(x)
    points = [-150, -100, -1, 0, 1, 42, 100, 200]
    for x in points:
        assert not (A(x) and (-A)(x))
    # A | -A is the full universe
    full = Intervals([('-oo', None)])
    for x in points:
        assert (A | -A)(x) == full(x)


@pytest.mark.parametrize("A", all_objs)
@pytest.mark.parametrize("B", all_objs)
def test_subset_equivalence(A, B):
    # A <= B iff (A & -B) == empty
    empty = Intervals([])
    assert (A <= B) == ((A & -B).intervals == ())


@pytest.mark.parametrize("A", all_objs)
@pytest.mark.parametrize("B", all_objs)
def test_symmetric_difference_membership(A, B):
    # For any x: (A^B)(x) == (A(x) != B(x))
    points = [-200, -100, -1, 0, 1, 50, 99, 200]
    for x in points:
        assert (A ^ B)(x) == (A(x) != B(x))

# Optionally, add performance tests with pytest-benchmark (see previous examples).

# To run: pytest test_intervals_axioms.py


# To run: pytest test_intervals_a.py --benchmark-enable
